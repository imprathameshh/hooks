The React useMemo Hook returns a memoized value.
useMemo is a React hook that allows you to memoize expensive computations and cache their results. 
It is used to optimize performance by avoiding unnecessary re-computation of values in functional components.


Basic Syntax:
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
computeExpensiveValue: The function that computes the expensive value.
[a, b]: An array of dependencies. If any of the dependencies change, the memoized value will be re-computed.
If the dependencies array is empty, the memoized value will only be computed once, similar to useEffect with an empty dependencies array.


Explanation:
0 - Memoizing Expensive Value:
In the example above, the expensiveValue is memoized using useMemo. The expensive computation is performed inside the function passed to useMemo.

1- Dependencies Array:
The count state variable is specified as a dependency in the dependencies array [count]. This means that the expensive value will be re-computed whenever count changes.

2 - Optimizing Performance:
Memoization ensures that the expensive computation is only performed when necessary. 
If count remains the same between renders, the memoized value will be returned from cache without re-computation. 

3 - Avoiding Unnecessary Re-Computation:
Without memoization, the expensive computation would be performed on every render,
potentially leading to performance issues, especially for complex computations.


Common Use Cases:
Optimizing Expensive Computations: Use useMemo to memoize the results of expensive computations or function calls.
Avoiding Re-Rendering: Memoize values to prevent unnecessary re-renders of components when the dependencies remain unchanged.
Caching Values: Memoize values to cache them between renders, improving performance in components that rely on those values.


In summary, useMemo is a powerful React hook that helps optimize performance by memoizing expensive computations and caching their results.
It's particularly useful for improving the efficiency of functional components and avoiding unnecessary re-computation of values.




