The useRef Hook allows you to persist values between renders.
It can be used to store a mutable value that does not cause a re-render when updated.
It can be used to access a DOM element directly.
The useRef hook in React allows functional components to keep mutable values persistently across renders.
Unlike useState, the value stored in a useRef persists between renders and does not trigger a re-render when it changes.

Basic Syntax:
const myRef = useRef(initialValue);
myRef is a mutable object that persists for the entire lifecycle of the component.
initialValue is the initial value of the ref.

Explanation:
Creating a Ref:

In the example above, inputRef is created using useRef(). Initially, it is set to null.

1 - Attaching Ref to an Element:
The ref attribute is used to attach the inputRef to the <input> element. 
This allows us to reference and manipulate the input element directly.

2 - Accessing the Ref's Current Value:
The current property of the ref object (inputRef.current) provides access to the DOM node or the value stored in the ref.\

3 - Manipulating the Ref:
In the example, focusInput is a function that focuses on the input element when called.
It uses inputRef.current to access the DOM node and invoke the focus() method.

4 - Persistent Across Renders:
Even though the component re-renders, the value of inputRef remains the same across renders.
This allows us to maintain references to elements or other mutable values without triggering re-renders.


Common Use Cases:
Accessing DOM Elements: useRef is commonly used to access DOM elements imperatively.
Managing Focus: It's useful for managing focus, as shown in the example above.
Storing Previous Values: useRef can store previous values or states without triggering re-renders.
Caching Values: It's often used to cache values between renders, especially in conjunction with useEffect.

In summary, useRef provides a way to maintain mutable values that persist between renders without triggering re-renders.
It's useful for accessing and manipulating DOM elements, managing focus, caching values, and more in functional components.


